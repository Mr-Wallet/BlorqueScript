grammar org.example.blorquescript.BlorqueScript with org.example.blorquescript.Terminals

generate blorqueScript "http://www.xtext.org/example/blorquescript/BlorqueScript"

BSFile:
	('package' name=QualifiedName ';')?
	imports+=BSImport*
	classes+=BSClass*
;

BSImport:
	'import' importedNamespace=QualifiedNameWithWildcard ';'
;

QualifiedNameWithWildcard:
	QualifiedName '.*'?
;

QualifiedName:
	ID ('.' ID)*
;

BSClass:
	'class' name=ID (':' superclass=[BSClass|QualifiedName])? '{'
		members+=BSMember*
	'}'
;

BSMember:
	BSField | BSMethod
;

BSField:
	type=[BSClass|QualifiedName] name=ID (isArray?='[' ']')? ';'
;

BSMethod:
	type=[BSClass|QualifiedName] name=ID
	'(' (params+=BSParameter (',' params+=BSParameter)*)? ')'
	body=BSMethodBody
;

BSParameter:
	type=[BSClass|QualifiedName] name=ID (isArray?='[' ']')?
;

BSMethodBody:
	{BSMethodBody} '{' statements+=BSStatement* '}'
;

BSStatement:
	BSVariableDeclaration |
	BSReturn |
	BSExpression ';' |
	BSIfStatement
	//TODO: for and while loops, switch($) statements
;

BSReturn:
	'return' expression=BSExpression ';'
;

BSVariableDeclaration:
	type=[BSClass|QualifiedName] name=ID ('=' expression=BSExpression)? ';'
;

BSIfStatement:
	'if' '(' expression=BSExpression ')' thenBlock=BSIfBlock
	(=> 'else' elseBlock=BSIfBlock)?
;

BSIfBlock:
	statements+=BSStatement
	| {BSIfBlock} '{' statements+=BSStatement* '}'
;

BSBlock:
	BSMethodBody | BSIfBlock
;

BSSymbol:
	BSVariableDeclaration | BSParameter | BSMember
;

BSExpression:
	BSAssignmentExpression
;

//right-to-left assignment operators: = and [op]=
BSAssignmentExpression returns BSExpression:
	BSTernaryExpression
	({BSAssignmentExpression.left=current} assignmentOperator=('='|'+='|'-='|'*='|'/='|'%='|'<<='|'>>='|'&='|'^='|'|=') right=BSExpression)?
;

//right-to-left ternary operator: (?:)
BSTernaryExpression returns BSExpression:
	BSBooleanOrExpression
	({BSTernaryExpression.left=current} '?' middle=BSExpression ':' right=BSExpression)?
;

//left-to-right boolean OR operator: ||
BSBooleanOrExpression returns BSExpression:
	BSBooleanAndExpression (
		{BSBooleanOrExpression.left=current} '||' right=BSBooleanAndExpression
	)*
;

//left-to-right boolean AND operator: &&
BSBooleanAndExpression returns BSExpression:
	BSBitwiseOrExpression (
		{BSBooleanAndExpression.left=current} '&&' right=BSBitwiseOrExpression
	)*
;

//left-to-right bitwise OR operator: |
BSBitwiseOrExpression returns BSExpression:
	BSBitwiseXorExpression (
		{BSBitwiseOrExpression.left=current} '|' right=BSBitwiseXorExpression
	)*
;

//left-to-right bitwise XOR operator: ^
BSBitwiseXorExpression returns BSExpression:
	BSBitwiseAndExpression (
		{BSBitwiseXorExpression.left=current} '^' right=BSBitwiseAndExpression
	)*
;

//left-to-right bitwise AND operator: &
BSBitwiseAndExpression returns BSExpression:
	BSEqualityExpression (
		{BSBitwiseAndExpression.left=current} '&' right=BSEqualityExpression
	)*
;

//left-to-right equality operators: == !=
BSEqualityExpression returns BSExpression:
	BSOrderedRelationExpression (
		{BSEqualityExpression.left=current} operator=('=='|'!=') right=BSOrderedRelationExpression
	)*
;

//left-to-right relational operators: < > <= >=
BSOrderedRelationExpression returns BSExpression:
	BSBitwiseShiftExpression (
		{BSOrderedRelationExpression.left=current} operator=('<'|'>'|'<='|'>=') right=BSBitwiseShiftExpression
	)*
;

//left-to-right bit-shift operators: << >>
BSBitwiseShiftExpression returns BSExpression:
	BSPlusMinusOrStringConcatExpression (
		{BSBitwiseShiftExpression.left=current} operator=('<<'|'>>') right=BSPlusMinusOrStringConcatExpression
	)*
;

//left-to-right additive operators: + - (string concat +) @ SPC NL TAB
BSPlusMinusOrStringConcatExpression returns BSExpression:
	BSMulDivOrModExpression (
		{BSPlusMinusOrStringConcatExpression.left=current} operator=('+'|'-'|'@'|'SPC'|'NL'|'TAB') right=BSMulDivOrModExpression
	)*
;

//left-to-right multiplication operators: * / %
BSMulDivOrModExpression returns BSExpression:
	BSCastOrNewExpression (
		{BSMulDivOrModExpression.left=current} operator=('*'|'/'|'%') right=BSCastOrNewExpression
	)*
;

//right-to-left prefix unary operators: (cast) new
BSCastOrNewExpression returns BSExpression:
	BSUnaryModifierExpression |
	{BSCastExpression} '(' castType=('string'|'number'|'object') ')' castExpr=BSCastOrNewExpression |
	{BSNewExpression} 'new' (isArray?='[' ']')? type=[BSClass|QualifiedName] '(' (args+=BSExpression (',' args+=BSExpression)*)? ')'	
;

//right-to-left prefix unary operators: + - ! ~
BSUnaryModifierExpression returns BSExpression:
	BSInvokationExpression |
	{BSUnaryModifierExpression} operator=('+'|'-'|'!'|'~')receiver=BSUnaryModifierExpression
;

//left-to-right unary postfixes: . (...) [...] ++ --
BSInvokationExpression returns BSExpression:
	BSTerminalExpression
	(
		{BSMemberSelectionExpression.receiver=current} '.'
		|
		{BSMethodInvokationExpression.receiver=current} '('
			(args+=BSExpression (',' args+=BSExpression)*)?
		')'
		|
		{BSArrayAccessExpression.receiver=current} '['
			(args+=BSExpression (',' args+=BSExpression)*)?
		']'
		|
		{BSPostfixArithmeticExpression.receiver=current} operator=('++'|'--')
	)*
;

//Maximum-precedence literals and keywords
BSTerminalExpression returns BSExpression:
	{BSStringConstant} value=STRING |
	{BSHexadecimalConstant} value=HEX_VALUE |
	{BSNumberConstant} value=INT ({BSRealConstant.left=current} '.' right=INT)? |
	{BSBooleanConstant} value=('true' | 'false') |
	{BSNullLiteral} 'null' |
	{BSBreakLiteral} 'break' |
	{BSContinueLiteral} 'continue' |
	{BSSwitchCase} 'case' expression=BSExpression | 
	{BSDefaultLiteral} 'default' |
	{BSThisLiteral} 'this' |
	{BSClientLiteral} 'client' |
	{BSParentLiteral} 'parent' |
	{BSSymbolRef} symbol=[BSSymbol] |
	{BSParentheticalExpression} '(' expression=BSExpression ')'
;

//TODO: figure out how to deal with special class names: global, servercmd, server, etc.

//Namespace (::) deliberately excluded, as it is only allowed in Global anyway.
//Instead, ':' is allowed in ID, and validation will forbid it anywhere but as a single '::' in global definitions.

