/*
 * generated by Xtext
 */
package org.xtext.example.blorquescript.serializer;

import com.google.inject.Inject;
import com.google.inject.Provider;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.serializer.acceptor.ISemanticSequenceAcceptor;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.diagnostic.ISemanticSequencerDiagnosticProvider;
import org.eclipse.xtext.serializer.diagnostic.ISerializationDiagnostic.Acceptor;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.GenericSequencer;
import org.eclipse.xtext.serializer.sequencer.ISemanticNodeProvider.INodesForEObjectProvider;
import org.eclipse.xtext.serializer.sequencer.ISemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.example.blorquescript.blorqueScript.BSAssignment;
import org.xtext.example.blorquescript.blorqueScript.BSBooleanConstant;
import org.xtext.example.blorquescript.blorqueScript.BSClass;
import org.xtext.example.blorquescript.blorqueScript.BSClient;
import org.xtext.example.blorquescript.blorqueScript.BSExpression;
import org.xtext.example.blorquescript.blorqueScript.BSField;
import org.xtext.example.blorquescript.blorqueScript.BSFile;
import org.xtext.example.blorquescript.blorqueScript.BSIfBlock;
import org.xtext.example.blorquescript.blorqueScript.BSIfStatement;
import org.xtext.example.blorquescript.blorqueScript.BSImport;
import org.xtext.example.blorquescript.blorqueScript.BSMemberSelection;
import org.xtext.example.blorquescript.blorqueScript.BSMethod;
import org.xtext.example.blorquescript.blorqueScript.BSMethodBody;
import org.xtext.example.blorquescript.blorqueScript.BSNew;
import org.xtext.example.blorquescript.blorqueScript.BSNull;
import org.xtext.example.blorquescript.blorqueScript.BSNumberConstant;
import org.xtext.example.blorquescript.blorqueScript.BSParameter;
import org.xtext.example.blorquescript.blorqueScript.BSReturn;
import org.xtext.example.blorquescript.blorqueScript.BSStringConstant;
import org.xtext.example.blorquescript.blorqueScript.BSSymbolRef;
import org.xtext.example.blorquescript.blorqueScript.BSThis;
import org.xtext.example.blorquescript.blorqueScript.BSVariableDeclaration;
import org.xtext.example.blorquescript.blorqueScript.BlorqueScriptPackage;
import org.xtext.example.blorquescript.services.BlorqueScriptGrammarAccess;

@SuppressWarnings("all")
public class BlorqueScriptSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private BlorqueScriptGrammarAccess grammarAccess;
	
	@Override
	public void createSequence(EObject context, EObject semanticObject) {
		if(semanticObject.eClass().getEPackage() == BlorqueScriptPackage.eINSTANCE) switch(semanticObject.eClass().getClassifierID()) {
			case BlorqueScriptPackage.BS_ASSIGNMENT:
				sequence_BSAssignment(context, (BSAssignment) semanticObject); 
				return; 
			case BlorqueScriptPackage.BS_BOOLEAN_CONSTANT:
				sequence_BSTerminalExpression(context, (BSBooleanConstant) semanticObject); 
				return; 
			case BlorqueScriptPackage.BS_CLASS:
				sequence_BSClass(context, (BSClass) semanticObject); 
				return; 
			case BlorqueScriptPackage.BS_CLIENT:
				sequence_BSTerminalExpression(context, (BSClient) semanticObject); 
				return; 
			case BlorqueScriptPackage.BS_EXPRESSION:
				sequence_BSCastingExpression(context, (BSExpression) semanticObject); 
				return; 
			case BlorqueScriptPackage.BS_FIELD:
				sequence_BSField(context, (BSField) semanticObject); 
				return; 
			case BlorqueScriptPackage.BS_FILE:
				sequence_BSFile(context, (BSFile) semanticObject); 
				return; 
			case BlorqueScriptPackage.BS_IF_BLOCK:
				sequence_BSIfBlock(context, (BSIfBlock) semanticObject); 
				return; 
			case BlorqueScriptPackage.BS_IF_STATEMENT:
				sequence_BSIfStatement(context, (BSIfStatement) semanticObject); 
				return; 
			case BlorqueScriptPackage.BS_IMPORT:
				sequence_BSImport(context, (BSImport) semanticObject); 
				return; 
			case BlorqueScriptPackage.BS_MEMBER_SELECTION:
				sequence_BSSelectionExpression(context, (BSMemberSelection) semanticObject); 
				return; 
			case BlorqueScriptPackage.BS_METHOD:
				sequence_BSMethod(context, (BSMethod) semanticObject); 
				return; 
			case BlorqueScriptPackage.BS_METHOD_BODY:
				sequence_BSMethodBody(context, (BSMethodBody) semanticObject); 
				return; 
			case BlorqueScriptPackage.BS_NEW:
				sequence_BSTerminalExpression(context, (BSNew) semanticObject); 
				return; 
			case BlorqueScriptPackage.BS_NULL:
				sequence_BSTerminalExpression(context, (BSNull) semanticObject); 
				return; 
			case BlorqueScriptPackage.BS_NUMBER_CONSTANT:
				sequence_BSTerminalExpression(context, (BSNumberConstant) semanticObject); 
				return; 
			case BlorqueScriptPackage.BS_PARAMETER:
				sequence_BSParameter(context, (BSParameter) semanticObject); 
				return; 
			case BlorqueScriptPackage.BS_RETURN:
				sequence_BSReturn(context, (BSReturn) semanticObject); 
				return; 
			case BlorqueScriptPackage.BS_STRING_CONSTANT:
				sequence_BSTerminalExpression(context, (BSStringConstant) semanticObject); 
				return; 
			case BlorqueScriptPackage.BS_SYMBOL_REF:
				sequence_BSTerminalExpression(context, (BSSymbolRef) semanticObject); 
				return; 
			case BlorqueScriptPackage.BS_THIS:
				sequence_BSTerminalExpression(context, (BSThis) semanticObject); 
				return; 
			case BlorqueScriptPackage.BS_VARIABLE_DECLARATION:
				sequence_BSVariableDeclaration(context, (BSVariableDeclaration) semanticObject); 
				return; 
			}
		if (errorAcceptor != null) errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Constraint:
	 *     (left=BSAssignment_BSAssignment_1_0 right=BSExpression)
	 */
	protected void sequence_BSAssignment(EObject context, BSAssignment semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     ((castType='string' | castType='number' | castType='object') castExpr=BSSelectionExpression)
	 */
	protected void sequence_BSCastingExpression(EObject context, BSExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID superclass=[BSClass|QualifiedName]? members+=BSMember*)
	 */
	protected void sequence_BSClass(EObject context, BSClass semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (type=[BSClass|QualifiedName] name=ID)
	 */
	protected void sequence_BSField(EObject context, BSField semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, BlorqueScriptPackage.Literals.BS_SYMBOL__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BlorqueScriptPackage.Literals.BS_SYMBOL__TYPE));
			if(transientValues.isValueTransient(semanticObject, BlorqueScriptPackage.Literals.BS_SYMBOL__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BlorqueScriptPackage.Literals.BS_SYMBOL__NAME));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getBSFieldAccess().getTypeBSClassQualifiedNameParserRuleCall_0_0_1(), semanticObject.getType());
		feeder.accept(grammarAccess.getBSFieldAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (name=QualifiedName? imports+=BSImport* classes+=BSClass*)
	 */
	protected void sequence_BSFile(EObject context, BSFile semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (statements+=BSStatement | statements+=BSStatement+)
	 */
	protected void sequence_BSIfBlock(EObject context, BSIfBlock semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (expression=BSExpression thenBlock=BSIfBlock elseBlock=BSIfBlock?)
	 */
	protected void sequence_BSIfStatement(EObject context, BSIfStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     importedNamespace=QualifiedNameWithWildcard
	 */
	protected void sequence_BSImport(EObject context, BSImport semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, BlorqueScriptPackage.Literals.BS_IMPORT__IMPORTED_NAMESPACE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BlorqueScriptPackage.Literals.BS_IMPORT__IMPORTED_NAMESPACE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getBSImportAccess().getImportedNamespaceQualifiedNameWithWildcardParserRuleCall_1_0(), semanticObject.getImportedNamespace());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (statements+=BSStatement*)
	 */
	protected void sequence_BSMethodBody(EObject context, BSMethodBody semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (type=[BSClass|QualifiedName] name=ID (params+=BSParameter params+=BSParameter*)? body=BSMethodBody)
	 */
	protected void sequence_BSMethod(EObject context, BSMethod semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (type=[BSClass|QualifiedName] name=ID)
	 */
	protected void sequence_BSParameter(EObject context, BSParameter semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, BlorqueScriptPackage.Literals.BS_SYMBOL__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BlorqueScriptPackage.Literals.BS_SYMBOL__TYPE));
			if(transientValues.isValueTransient(semanticObject, BlorqueScriptPackage.Literals.BS_SYMBOL__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BlorqueScriptPackage.Literals.BS_SYMBOL__NAME));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getBSParameterAccess().getTypeBSClassQualifiedNameParserRuleCall_0_0_1(), semanticObject.getType());
		feeder.accept(grammarAccess.getBSParameterAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     expression=BSExpression
	 */
	protected void sequence_BSReturn(EObject context, BSReturn semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, BlorqueScriptPackage.Literals.BS_RETURN__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BlorqueScriptPackage.Literals.BS_RETURN__EXPRESSION));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getBSReturnAccess().getExpressionBSExpressionParserRuleCall_1_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (receiver=BSSelectionExpression_BSMemberSelection_1_0 member=[BSMember|ID] (methodinvocation?='(' (args+=BSExpression args+=BSExpression*)?)?)
	 */
	protected void sequence_BSSelectionExpression(EObject context, BSMemberSelection semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (value='true' | value='false')
	 */
	protected void sequence_BSTerminalExpression(EObject context, BSBooleanConstant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     {BSClient}
	 */
	protected void sequence_BSTerminalExpression(EObject context, BSClient semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (type=[BSClass|QualifiedName] (args+=BSExpression args+=BSExpression*)?)
	 */
	protected void sequence_BSTerminalExpression(EObject context, BSNew semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     {BSNull}
	 */
	protected void sequence_BSTerminalExpression(EObject context, BSNull semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     value=INT
	 */
	protected void sequence_BSTerminalExpression(EObject context, BSNumberConstant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     value=STRING
	 */
	protected void sequence_BSTerminalExpression(EObject context, BSStringConstant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (symbol=[BSSymbol|ID] (methodinvocation?='(' (args+=BSExpression args+=BSExpression*)?)?)
	 */
	protected void sequence_BSTerminalExpression(EObject context, BSSymbolRef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     {BSThis}
	 */
	protected void sequence_BSTerminalExpression(EObject context, BSThis semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (type=[BSClass|QualifiedName] name=ID expression=BSExpression?)
	 */
	protected void sequence_BSVariableDeclaration(EObject context, BSVariableDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
}
