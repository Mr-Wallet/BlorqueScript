/*
 * generated by Xtext
 */
package org.example.blorquescript.serializer;

import com.google.inject.Inject;
import com.google.inject.Provider;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.serializer.acceptor.ISemanticSequenceAcceptor;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.diagnostic.ISemanticSequencerDiagnosticProvider;
import org.eclipse.xtext.serializer.diagnostic.ISerializationDiagnostic.Acceptor;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.GenericSequencer;
import org.eclipse.xtext.serializer.sequencer.ISemanticNodeProvider.INodesForEObjectProvider;
import org.eclipse.xtext.serializer.sequencer.ISemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.example.blorquescript.blorqueScript.BSArrayAccessExpression;
import org.example.blorquescript.blorqueScript.BSAssignmentExpression;
import org.example.blorquescript.blorqueScript.BSBitwiseAndExpression;
import org.example.blorquescript.blorqueScript.BSBitwiseOrExpression;
import org.example.blorquescript.blorqueScript.BSBitwiseShiftExpression;
import org.example.blorquescript.blorqueScript.BSBitwiseXorExpression;
import org.example.blorquescript.blorqueScript.BSBooleanAndExpression;
import org.example.blorquescript.blorqueScript.BSBooleanConstant;
import org.example.blorquescript.blorqueScript.BSBooleanOrExpression;
import org.example.blorquescript.blorqueScript.BSBreakLiteral;
import org.example.blorquescript.blorqueScript.BSCase;
import org.example.blorquescript.blorqueScript.BSCaseBlock;
import org.example.blorquescript.blorqueScript.BSCastExpression;
import org.example.blorquescript.blorqueScript.BSClass;
import org.example.blorquescript.blorqueScript.BSClientLiteral;
import org.example.blorquescript.blorqueScript.BSContinueLiteral;
import org.example.blorquescript.blorqueScript.BSEqualityExpression;
import org.example.blorquescript.blorqueScript.BSField;
import org.example.blorquescript.blorqueScript.BSFile;
import org.example.blorquescript.blorqueScript.BSForLoop;
import org.example.blorquescript.blorqueScript.BSHexadecimalConstant;
import org.example.blorquescript.blorqueScript.BSIfBlock;
import org.example.blorquescript.blorqueScript.BSIfStatement;
import org.example.blorquescript.blorqueScript.BSImport;
import org.example.blorquescript.blorqueScript.BSLoopBlock;
import org.example.blorquescript.blorqueScript.BSMemberSelectionExpression;
import org.example.blorquescript.blorqueScript.BSMethod;
import org.example.blorquescript.blorqueScript.BSMethodBody;
import org.example.blorquescript.blorqueScript.BSMethodInvokationExpression;
import org.example.blorquescript.blorqueScript.BSMulDivOrModExpression;
import org.example.blorquescript.blorqueScript.BSNewExpression;
import org.example.blorquescript.blorqueScript.BSNullLiteral;
import org.example.blorquescript.blorqueScript.BSNumberConstant;
import org.example.blorquescript.blorqueScript.BSOrderedRelationExpression;
import org.example.blorquescript.blorqueScript.BSParameter;
import org.example.blorquescript.blorqueScript.BSParentLiteral;
import org.example.blorquescript.blorqueScript.BSParentheticalExpression;
import org.example.blorquescript.blorqueScript.BSPlusMinusOrStringConcatExpression;
import org.example.blorquescript.blorqueScript.BSPostfixArithmeticExpression;
import org.example.blorquescript.blorqueScript.BSRealConstant;
import org.example.blorquescript.blorqueScript.BSReturn;
import org.example.blorquescript.blorqueScript.BSStringConstant;
import org.example.blorquescript.blorqueScript.BSSwitchBlock;
import org.example.blorquescript.blorqueScript.BSSwitchStatement;
import org.example.blorquescript.blorqueScript.BSSymbolRef;
import org.example.blorquescript.blorqueScript.BSTernaryExpression;
import org.example.blorquescript.blorqueScript.BSThisLiteral;
import org.example.blorquescript.blorqueScript.BSUnaryModifierExpression;
import org.example.blorquescript.blorqueScript.BSVariableDeclaration;
import org.example.blorquescript.blorqueScript.BSWhileLoop;
import org.example.blorquescript.blorqueScript.BlorqueScriptPackage;
import org.example.blorquescript.services.BlorqueScriptGrammarAccess;

@SuppressWarnings("all")
public class BlorqueScriptSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private BlorqueScriptGrammarAccess grammarAccess;
	
	@Override
	public void createSequence(EObject context, EObject semanticObject) {
		if(semanticObject.eClass().getEPackage() == BlorqueScriptPackage.eINSTANCE) switch(semanticObject.eClass().getClassifierID()) {
			case BlorqueScriptPackage.BS_ARRAY_ACCESS_EXPRESSION:
				sequence_BSInvokationExpression(context, (BSArrayAccessExpression) semanticObject); 
				return; 
			case BlorqueScriptPackage.BS_ASSIGNMENT_EXPRESSION:
				sequence_BSAssignmentExpression(context, (BSAssignmentExpression) semanticObject); 
				return; 
			case BlorqueScriptPackage.BS_BITWISE_AND_EXPRESSION:
				sequence_BSBitwiseAndExpression(context, (BSBitwiseAndExpression) semanticObject); 
				return; 
			case BlorqueScriptPackage.BS_BITWISE_OR_EXPRESSION:
				sequence_BSBitwiseOrExpression(context, (BSBitwiseOrExpression) semanticObject); 
				return; 
			case BlorqueScriptPackage.BS_BITWISE_SHIFT_EXPRESSION:
				sequence_BSBitwiseShiftExpression(context, (BSBitwiseShiftExpression) semanticObject); 
				return; 
			case BlorqueScriptPackage.BS_BITWISE_XOR_EXPRESSION:
				sequence_BSBitwiseXorExpression(context, (BSBitwiseXorExpression) semanticObject); 
				return; 
			case BlorqueScriptPackage.BS_BOOLEAN_AND_EXPRESSION:
				sequence_BSBooleanAndExpression(context, (BSBooleanAndExpression) semanticObject); 
				return; 
			case BlorqueScriptPackage.BS_BOOLEAN_CONSTANT:
				sequence_BSTerminalExpression(context, (BSBooleanConstant) semanticObject); 
				return; 
			case BlorqueScriptPackage.BS_BOOLEAN_OR_EXPRESSION:
				sequence_BSBooleanOrExpression(context, (BSBooleanOrExpression) semanticObject); 
				return; 
			case BlorqueScriptPackage.BS_BREAK_LITERAL:
				sequence_BSTerminalExpression(context, (BSBreakLiteral) semanticObject); 
				return; 
			case BlorqueScriptPackage.BS_CASE:
				sequence_BSCase(context, (BSCase) semanticObject); 
				return; 
			case BlorqueScriptPackage.BS_CASE_BLOCK:
				sequence_BSCaseBlock(context, (BSCaseBlock) semanticObject); 
				return; 
			case BlorqueScriptPackage.BS_CAST_EXPRESSION:
				sequence_BSCastOrNewExpression(context, (BSCastExpression) semanticObject); 
				return; 
			case BlorqueScriptPackage.BS_CLASS:
				sequence_BSClass(context, (BSClass) semanticObject); 
				return; 
			case BlorqueScriptPackage.BS_CLIENT_LITERAL:
				sequence_BSTerminalExpression(context, (BSClientLiteral) semanticObject); 
				return; 
			case BlorqueScriptPackage.BS_CONTINUE_LITERAL:
				sequence_BSTerminalExpression(context, (BSContinueLiteral) semanticObject); 
				return; 
			case BlorqueScriptPackage.BS_EQUALITY_EXPRESSION:
				sequence_BSEqualityExpression(context, (BSEqualityExpression) semanticObject); 
				return; 
			case BlorqueScriptPackage.BS_FIELD:
				sequence_BSField(context, (BSField) semanticObject); 
				return; 
			case BlorqueScriptPackage.BS_FILE:
				sequence_BSFile(context, (BSFile) semanticObject); 
				return; 
			case BlorqueScriptPackage.BS_FOR_LOOP:
				sequence_BSForLoop(context, (BSForLoop) semanticObject); 
				return; 
			case BlorqueScriptPackage.BS_HEXADECIMAL_CONSTANT:
				sequence_BSTerminalExpression(context, (BSHexadecimalConstant) semanticObject); 
				return; 
			case BlorqueScriptPackage.BS_IF_BLOCK:
				sequence_BSIfBlock(context, (BSIfBlock) semanticObject); 
				return; 
			case BlorqueScriptPackage.BS_IF_STATEMENT:
				sequence_BSIfStatement(context, (BSIfStatement) semanticObject); 
				return; 
			case BlorqueScriptPackage.BS_IMPORT:
				sequence_BSImport(context, (BSImport) semanticObject); 
				return; 
			case BlorqueScriptPackage.BS_LOOP_BLOCK:
				sequence_BSLoopBlock(context, (BSLoopBlock) semanticObject); 
				return; 
			case BlorqueScriptPackage.BS_MEMBER_SELECTION_EXPRESSION:
				sequence_BSInvokationExpression(context, (BSMemberSelectionExpression) semanticObject); 
				return; 
			case BlorqueScriptPackage.BS_METHOD:
				sequence_BSMethod(context, (BSMethod) semanticObject); 
				return; 
			case BlorqueScriptPackage.BS_METHOD_BODY:
				sequence_BSMethodBody(context, (BSMethodBody) semanticObject); 
				return; 
			case BlorqueScriptPackage.BS_METHOD_INVOKATION_EXPRESSION:
				sequence_BSInvokationExpression(context, (BSMethodInvokationExpression) semanticObject); 
				return; 
			case BlorqueScriptPackage.BS_MUL_DIV_OR_MOD_EXPRESSION:
				sequence_BSMulDivOrModExpression(context, (BSMulDivOrModExpression) semanticObject); 
				return; 
			case BlorqueScriptPackage.BS_NEW_EXPRESSION:
				sequence_BSCastOrNewExpression(context, (BSNewExpression) semanticObject); 
				return; 
			case BlorqueScriptPackage.BS_NULL_LITERAL:
				sequence_BSTerminalExpression(context, (BSNullLiteral) semanticObject); 
				return; 
			case BlorqueScriptPackage.BS_NUMBER_CONSTANT:
				sequence_BSTerminalExpression(context, (BSNumberConstant) semanticObject); 
				return; 
			case BlorqueScriptPackage.BS_ORDERED_RELATION_EXPRESSION:
				sequence_BSOrderedRelationExpression(context, (BSOrderedRelationExpression) semanticObject); 
				return; 
			case BlorqueScriptPackage.BS_PARAMETER:
				sequence_BSParameter(context, (BSParameter) semanticObject); 
				return; 
			case BlorqueScriptPackage.BS_PARENT_LITERAL:
				sequence_BSTerminalExpression(context, (BSParentLiteral) semanticObject); 
				return; 
			case BlorqueScriptPackage.BS_PARENTHETICAL_EXPRESSION:
				sequence_BSTerminalExpression(context, (BSParentheticalExpression) semanticObject); 
				return; 
			case BlorqueScriptPackage.BS_PLUS_MINUS_OR_STRING_CONCAT_EXPRESSION:
				sequence_BSPlusMinusOrStringConcatExpression(context, (BSPlusMinusOrStringConcatExpression) semanticObject); 
				return; 
			case BlorqueScriptPackage.BS_POSTFIX_ARITHMETIC_EXPRESSION:
				sequence_BSInvokationExpression(context, (BSPostfixArithmeticExpression) semanticObject); 
				return; 
			case BlorqueScriptPackage.BS_REAL_CONSTANT:
				sequence_BSTerminalExpression(context, (BSRealConstant) semanticObject); 
				return; 
			case BlorqueScriptPackage.BS_RETURN:
				sequence_BSReturn(context, (BSReturn) semanticObject); 
				return; 
			case BlorqueScriptPackage.BS_STRING_CONSTANT:
				sequence_BSTerminalExpression(context, (BSStringConstant) semanticObject); 
				return; 
			case BlorqueScriptPackage.BS_SWITCH_BLOCK:
				sequence_BSSwitchBlock(context, (BSSwitchBlock) semanticObject); 
				return; 
			case BlorqueScriptPackage.BS_SWITCH_STATEMENT:
				sequence_BSSwitchStatement(context, (BSSwitchStatement) semanticObject); 
				return; 
			case BlorqueScriptPackage.BS_SYMBOL_REF:
				sequence_BSTerminalExpression(context, (BSSymbolRef) semanticObject); 
				return; 
			case BlorqueScriptPackage.BS_TERNARY_EXPRESSION:
				sequence_BSTernaryExpression(context, (BSTernaryExpression) semanticObject); 
				return; 
			case BlorqueScriptPackage.BS_THIS_LITERAL:
				sequence_BSTerminalExpression(context, (BSThisLiteral) semanticObject); 
				return; 
			case BlorqueScriptPackage.BS_UNARY_MODIFIER_EXPRESSION:
				sequence_BSUnaryModifierExpression(context, (BSUnaryModifierExpression) semanticObject); 
				return; 
			case BlorqueScriptPackage.BS_VARIABLE_DECLARATION:
				sequence_BSVariableDeclaration(context, (BSVariableDeclaration) semanticObject); 
				return; 
			case BlorqueScriptPackage.BS_WHILE_LOOP:
				sequence_BSWhileLoop(context, (BSWhileLoop) semanticObject); 
				return; 
			}
		if (errorAcceptor != null) errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Constraint:
	 *     (
	 *         left=BSAssignmentExpression_BSAssignmentExpression_1_0 
	 *         (
	 *             assignmentOperator='=' | 
	 *             assignmentOperator='@=' | 
	 *             assignmentOperator='+=' | 
	 *             assignmentOperator='-=' | 
	 *             assignmentOperator='*=' | 
	 *             assignmentOperator='/=' | 
	 *             assignmentOperator='%=' | 
	 *             assignmentOperator='<<=' | 
	 *             assignmentOperator='>>=' | 
	 *             assignmentOperator='&=' | 
	 *             assignmentOperator='^=' | 
	 *             assignmentOperator='|='
	 *         ) 
	 *         right=BSExpression
	 *     )
	 */
	protected void sequence_BSAssignmentExpression(EObject context, BSAssignmentExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (left=BSBitwiseAndExpression_BSBitwiseAndExpression_1_0 right=BSEqualityExpression)
	 */
	protected void sequence_BSBitwiseAndExpression(EObject context, BSBitwiseAndExpression semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, BlorqueScriptPackage.Literals.BS_BITWISE_AND_EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BlorqueScriptPackage.Literals.BS_BITWISE_AND_EXPRESSION__LEFT));
			if(transientValues.isValueTransient(semanticObject, BlorqueScriptPackage.Literals.BS_BITWISE_AND_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BlorqueScriptPackage.Literals.BS_BITWISE_AND_EXPRESSION__RIGHT));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getBSBitwiseAndExpressionAccess().getBSBitwiseAndExpressionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getBSBitwiseAndExpressionAccess().getRightBSEqualityExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (left=BSBitwiseOrExpression_BSBitwiseOrExpression_1_0 right=BSBitwiseXorExpression)
	 */
	protected void sequence_BSBitwiseOrExpression(EObject context, BSBitwiseOrExpression semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, BlorqueScriptPackage.Literals.BS_BITWISE_OR_EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BlorqueScriptPackage.Literals.BS_BITWISE_OR_EXPRESSION__LEFT));
			if(transientValues.isValueTransient(semanticObject, BlorqueScriptPackage.Literals.BS_BITWISE_OR_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BlorqueScriptPackage.Literals.BS_BITWISE_OR_EXPRESSION__RIGHT));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getBSBitwiseOrExpressionAccess().getBSBitwiseOrExpressionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getBSBitwiseOrExpressionAccess().getRightBSBitwiseXorExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (left=BSBitwiseShiftExpression_BSBitwiseShiftExpression_1_0 (operator='<<' | operator='>>') right=BSPlusMinusOrStringConcatExpression)
	 */
	protected void sequence_BSBitwiseShiftExpression(EObject context, BSBitwiseShiftExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (left=BSBitwiseXorExpression_BSBitwiseXorExpression_1_0 right=BSBitwiseAndExpression)
	 */
	protected void sequence_BSBitwiseXorExpression(EObject context, BSBitwiseXorExpression semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, BlorqueScriptPackage.Literals.BS_BITWISE_XOR_EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BlorqueScriptPackage.Literals.BS_BITWISE_XOR_EXPRESSION__LEFT));
			if(transientValues.isValueTransient(semanticObject, BlorqueScriptPackage.Literals.BS_BITWISE_XOR_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BlorqueScriptPackage.Literals.BS_BITWISE_XOR_EXPRESSION__RIGHT));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getBSBitwiseXorExpressionAccess().getBSBitwiseXorExpressionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getBSBitwiseXorExpressionAccess().getRightBSBitwiseAndExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (left=BSBooleanAndExpression_BSBooleanAndExpression_1_0 right=BSBitwiseOrExpression)
	 */
	protected void sequence_BSBooleanAndExpression(EObject context, BSBooleanAndExpression semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, BlorqueScriptPackage.Literals.BS_BOOLEAN_AND_EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BlorqueScriptPackage.Literals.BS_BOOLEAN_AND_EXPRESSION__LEFT));
			if(transientValues.isValueTransient(semanticObject, BlorqueScriptPackage.Literals.BS_BOOLEAN_AND_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BlorqueScriptPackage.Literals.BS_BOOLEAN_AND_EXPRESSION__RIGHT));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getBSBooleanAndExpressionAccess().getBSBooleanAndExpressionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getBSBooleanAndExpressionAccess().getRightBSBitwiseOrExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (left=BSBooleanOrExpression_BSBooleanOrExpression_1_0 right=BSBooleanAndExpression)
	 */
	protected void sequence_BSBooleanOrExpression(EObject context, BSBooleanOrExpression semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, BlorqueScriptPackage.Literals.BS_BOOLEAN_OR_EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BlorqueScriptPackage.Literals.BS_BOOLEAN_OR_EXPRESSION__LEFT));
			if(transientValues.isValueTransient(semanticObject, BlorqueScriptPackage.Literals.BS_BOOLEAN_OR_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BlorqueScriptPackage.Literals.BS_BOOLEAN_OR_EXPRESSION__RIGHT));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getBSBooleanOrExpressionAccess().getBSBooleanOrExpressionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getBSBooleanOrExpressionAccess().getRightBSBooleanAndExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (statements+=BSStatement*)
	 */
	protected void sequence_BSCaseBlock(EObject context, BSCaseBlock semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     ((expression=BSExpression block=BSCaseBlock) | block=BSCaseBlock)
	 */
	protected void sequence_BSCase(EObject context, BSCase semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     ((castType='string' | castType='number' | castType='object') castExpr=BSCastOrNewExpression)
	 */
	protected void sequence_BSCastOrNewExpression(EObject context, BSCastExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (isArray?='['? type=[BSClass|QualifiedName] (args+=BSExpression args+=BSExpression*)?)
	 */
	protected void sequence_BSCastOrNewExpression(EObject context, BSNewExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID superclass=[BSClass|QualifiedName]? members+=BSMember*)
	 */
	protected void sequence_BSClass(EObject context, BSClass semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (left=BSEqualityExpression_BSEqualityExpression_1_0 (operator='==' | operator='!=') right=BSOrderedRelationExpression)
	 */
	protected void sequence_BSEqualityExpression(EObject context, BSEqualityExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (type=[BSClass|QualifiedName] name=ID isArray?='['?)
	 */
	protected void sequence_BSField(EObject context, BSField semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=QualifiedName? imports+=BSImport* classes+=BSClass*)
	 */
	protected void sequence_BSFile(EObject context, BSFile semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (left=BSExpression middle=BSExpression right=BSExpression block=BSLoopBlock)
	 */
	protected void sequence_BSForLoop(EObject context, BSForLoop semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, BlorqueScriptPackage.Literals.BS_FOR_LOOP__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BlorqueScriptPackage.Literals.BS_FOR_LOOP__LEFT));
			if(transientValues.isValueTransient(semanticObject, BlorqueScriptPackage.Literals.BS_FOR_LOOP__MIDDLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BlorqueScriptPackage.Literals.BS_FOR_LOOP__MIDDLE));
			if(transientValues.isValueTransient(semanticObject, BlorqueScriptPackage.Literals.BS_FOR_LOOP__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BlorqueScriptPackage.Literals.BS_FOR_LOOP__RIGHT));
			if(transientValues.isValueTransient(semanticObject, BlorqueScriptPackage.Literals.BS_FOR_LOOP__BLOCK) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BlorqueScriptPackage.Literals.BS_FOR_LOOP__BLOCK));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getBSForLoopAccess().getLeftBSExpressionParserRuleCall_2_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getBSForLoopAccess().getMiddleBSExpressionParserRuleCall_4_0(), semanticObject.getMiddle());
		feeder.accept(grammarAccess.getBSForLoopAccess().getRightBSExpressionParserRuleCall_6_0(), semanticObject.getRight());
		feeder.accept(grammarAccess.getBSForLoopAccess().getBlockBSLoopBlockParserRuleCall_8_0(), semanticObject.getBlock());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (statements+=BSStatement*)
	 */
	protected void sequence_BSIfBlock(EObject context, BSIfBlock semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (expression=BSExpression thenBlock=BSIfBlock elseBlock=BSIfBlock?)
	 */
	protected void sequence_BSIfStatement(EObject context, BSIfStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     importedNamespace=QualifiedNameWithWildcard
	 */
	protected void sequence_BSImport(EObject context, BSImport semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, BlorqueScriptPackage.Literals.BS_IMPORT__IMPORTED_NAMESPACE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BlorqueScriptPackage.Literals.BS_IMPORT__IMPORTED_NAMESPACE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getBSImportAccess().getImportedNamespaceQualifiedNameWithWildcardParserRuleCall_1_0(), semanticObject.getImportedNamespace());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         (receiver=BSInvokationExpression_BSArrayAccessExpression_1_2_0 (args+=BSExpression args+=BSExpression*)?) | 
	 *         receiver=BSInvokationExpression_BSArrayAccessExpression_1_2_0
	 *     )
	 */
	protected void sequence_BSInvokationExpression(EObject context, BSArrayAccessExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     receiver=BSInvokationExpression_BSMemberSelectionExpression_1_0_0
	 */
	protected void sequence_BSInvokationExpression(EObject context, BSMemberSelectionExpression semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, BlorqueScriptPackage.Literals.BS_MEMBER_SELECTION_EXPRESSION__RECEIVER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BlorqueScriptPackage.Literals.BS_MEMBER_SELECTION_EXPRESSION__RECEIVER));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getBSInvokationExpressionAccess().getBSMemberSelectionExpressionReceiverAction_1_0_0(), semanticObject.getReceiver());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         (receiver=BSInvokationExpression_BSMethodInvokationExpression_1_1_0 (args+=BSExpression args+=BSExpression*)?) | 
	 *         receiver=BSInvokationExpression_BSMethodInvokationExpression_1_1_0
	 *     )
	 */
	protected void sequence_BSInvokationExpression(EObject context, BSMethodInvokationExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (receiver=BSInvokationExpression_BSPostfixArithmeticExpression_1_3_0 (operator='++' | operator='--'))
	 */
	protected void sequence_BSInvokationExpression(EObject context, BSPostfixArithmeticExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (statements+=BSStatement*)
	 */
	protected void sequence_BSLoopBlock(EObject context, BSLoopBlock semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (statements+=BSStatement*)
	 */
	protected void sequence_BSMethodBody(EObject context, BSMethodBody semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (type=[BSClass|QualifiedName] name=ID (params+=BSParameter params+=BSParameter*)? body=BSMethodBody)
	 */
	protected void sequence_BSMethod(EObject context, BSMethod semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (left=BSMulDivOrModExpression_BSMulDivOrModExpression_1_0 (operator='*' | operator='/' | operator='%') right=BSCastOrNewExpression)
	 */
	protected void sequence_BSMulDivOrModExpression(EObject context, BSMulDivOrModExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         left=BSOrderedRelationExpression_BSOrderedRelationExpression_1_0 
	 *         (operator='<' | operator='>' | operator='<=' | operator='>=') 
	 *         right=BSBitwiseShiftExpression
	 *     )
	 */
	protected void sequence_BSOrderedRelationExpression(EObject context, BSOrderedRelationExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (type=[BSClass|QualifiedName] name=ID isArray?='['?)
	 */
	protected void sequence_BSParameter(EObject context, BSParameter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (
	 *         left=BSPlusMinusOrStringConcatExpression_BSPlusMinusOrStringConcatExpression_1_0 
	 *         (
	 *             operator='+' | 
	 *             operator='-' | 
	 *             operator='@' | 
	 *             operator='SPC' | 
	 *             operator='NL' | 
	 *             operator='TAB'
	 *         ) 
	 *         right=BSMulDivOrModExpression
	 *     )
	 */
	protected void sequence_BSPlusMinusOrStringConcatExpression(EObject context, BSPlusMinusOrStringConcatExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     expression=BSExpression
	 */
	protected void sequence_BSReturn(EObject context, BSReturn semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, BlorqueScriptPackage.Literals.BS_RETURN__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BlorqueScriptPackage.Literals.BS_RETURN__EXPRESSION));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getBSReturnAccess().getExpressionBSExpressionParserRuleCall_1_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (cases+=BSCase*)
	 */
	protected void sequence_BSSwitchBlock(EObject context, BSSwitchBlock semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (stringSwitch?='$'? expression=BSExpression block=BSSwitchBlock)
	 */
	protected void sequence_BSSwitchStatement(EObject context, BSSwitchStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (value='true' | value='false')
	 */
	protected void sequence_BSTerminalExpression(EObject context, BSBooleanConstant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     {BSBreakLiteral}
	 */
	protected void sequence_BSTerminalExpression(EObject context, BSBreakLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     {BSClientLiteral}
	 */
	protected void sequence_BSTerminalExpression(EObject context, BSClientLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     {BSContinueLiteral}
	 */
	protected void sequence_BSTerminalExpression(EObject context, BSContinueLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     value=HEX_VALUE
	 */
	protected void sequence_BSTerminalExpression(EObject context, BSHexadecimalConstant semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, BlorqueScriptPackage.Literals.BS_HEXADECIMAL_CONSTANT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BlorqueScriptPackage.Literals.BS_HEXADECIMAL_CONSTANT__VALUE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getBSTerminalExpressionAccess().getValueHEX_VALUETerminalRuleCall_1_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     {BSNullLiteral}
	 */
	protected void sequence_BSTerminalExpression(EObject context, BSNullLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     value=INT
	 */
	protected void sequence_BSTerminalExpression(EObject context, BSNumberConstant semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, BlorqueScriptPackage.Literals.BS_NUMBER_CONSTANT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BlorqueScriptPackage.Literals.BS_NUMBER_CONSTANT__VALUE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getBSTerminalExpressionAccess().getValueINTTerminalRuleCall_2_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     {BSParentLiteral}
	 */
	protected void sequence_BSTerminalExpression(EObject context, BSParentLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     expression=BSExpression
	 */
	protected void sequence_BSTerminalExpression(EObject context, BSParentheticalExpression semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, BlorqueScriptPackage.Literals.BS_PARENTHETICAL_EXPRESSION__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BlorqueScriptPackage.Literals.BS_PARENTHETICAL_EXPRESSION__EXPRESSION));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getBSTerminalExpressionAccess().getExpressionBSExpressionParserRuleCall_11_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (left=BSTerminalExpression_BSRealConstant_2_2_0 right=INT)
	 */
	protected void sequence_BSTerminalExpression(EObject context, BSRealConstant semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, BlorqueScriptPackage.Literals.BS_REAL_CONSTANT__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BlorqueScriptPackage.Literals.BS_REAL_CONSTANT__LEFT));
			if(transientValues.isValueTransient(semanticObject, BlorqueScriptPackage.Literals.BS_REAL_CONSTANT__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BlorqueScriptPackage.Literals.BS_REAL_CONSTANT__RIGHT));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getBSTerminalExpressionAccess().getBSRealConstantLeftAction_2_2_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getBSTerminalExpressionAccess().getRightINTTerminalRuleCall_2_2_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     value=STRING
	 */
	protected void sequence_BSTerminalExpression(EObject context, BSStringConstant semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, BlorqueScriptPackage.Literals.BS_STRING_CONSTANT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BlorqueScriptPackage.Literals.BS_STRING_CONSTANT__VALUE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getBSTerminalExpressionAccess().getValueSTRINGTerminalRuleCall_0_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     symbol=[BSSymbol|ID]
	 */
	protected void sequence_BSTerminalExpression(EObject context, BSSymbolRef semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, BlorqueScriptPackage.Literals.BS_SYMBOL_REF__SYMBOL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BlorqueScriptPackage.Literals.BS_SYMBOL_REF__SYMBOL));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getBSTerminalExpressionAccess().getSymbolBSSymbolIDTerminalRuleCall_10_1_0_1(), semanticObject.getSymbol());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     {BSThisLiteral}
	 */
	protected void sequence_BSTerminalExpression(EObject context, BSThisLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (left=BSTernaryExpression_BSTernaryExpression_1_0 middle=BSExpression right=BSExpression)
	 */
	protected void sequence_BSTernaryExpression(EObject context, BSTernaryExpression semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, BlorqueScriptPackage.Literals.BS_TERNARY_EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BlorqueScriptPackage.Literals.BS_TERNARY_EXPRESSION__LEFT));
			if(transientValues.isValueTransient(semanticObject, BlorqueScriptPackage.Literals.BS_TERNARY_EXPRESSION__MIDDLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BlorqueScriptPackage.Literals.BS_TERNARY_EXPRESSION__MIDDLE));
			if(transientValues.isValueTransient(semanticObject, BlorqueScriptPackage.Literals.BS_TERNARY_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BlorqueScriptPackage.Literals.BS_TERNARY_EXPRESSION__RIGHT));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getBSTernaryExpressionAccess().getBSTernaryExpressionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getBSTernaryExpressionAccess().getMiddleBSExpressionParserRuleCall_1_2_0(), semanticObject.getMiddle());
		feeder.accept(grammarAccess.getBSTernaryExpressionAccess().getRightBSExpressionParserRuleCall_1_4_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     ((operator='+' | operator='-' | operator='!' | operator='~') receiver=BSUnaryModifierExpression)
	 */
	protected void sequence_BSUnaryModifierExpression(EObject context, BSUnaryModifierExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (type=[BSClass|QualifiedName] name=ID expression=BSExpression?)
	 */
	protected void sequence_BSVariableDeclaration(EObject context, BSVariableDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (expression=BSExpression block=BSLoopBlock)
	 */
	protected void sequence_BSWhileLoop(EObject context, BSWhileLoop semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, BlorqueScriptPackage.Literals.BS_WHILE_LOOP__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BlorqueScriptPackage.Literals.BS_WHILE_LOOP__EXPRESSION));
			if(transientValues.isValueTransient(semanticObject, BlorqueScriptPackage.Literals.BS_WHILE_LOOP__BLOCK) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BlorqueScriptPackage.Literals.BS_WHILE_LOOP__BLOCK));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getBSWhileLoopAccess().getExpressionBSExpressionParserRuleCall_2_0(), semanticObject.getExpression());
		feeder.accept(grammarAccess.getBSWhileLoopAccess().getBlockBSLoopBlockParserRuleCall_4_0(), semanticObject.getBlock());
		feeder.finish();
	}
}
